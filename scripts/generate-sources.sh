# This script searching for AdventofCode.com puzzle input files and creates
# Haskell source files where you can solve those puzzles. Its purpose is to save
# you from the tedium of manually creating and linking source files each day.
#
# This script also generates a GeneratedSolutions.hs file exposing a lookup-list
# of every available puzzle solution found in the source directory and one of
# each available input file.

ROOT_DIR="inputs"
SRC_DIR="src"
GENERATED_FILE="$SRC_DIR/GeneratedSolutions.hs"
EXAMPLE_PATHS="'$ROOT_DIR/YYYY/DD' or '$ROOT_DIR/YYYY/D'"

createSourceFromInputFile() {
    local f="$1"
    local day="$(basename "$f")"
    local year="$(basename "$(dirname "$f")")"

    if [[ ! ("$year" =~ ^[0-9]{4}$) ]]; then
        msg "$f: ${RED}Invalid year format.${NOFORMAT} Expected $EXAMPLE_PATHS"
        return
    fi
    if [[ ! ("$day" =~ ^[0-9]{1,2}$) ]]; then
        msg "$f: ${RED}Invalid day format.${NOFORMAT} Expected $EXAMPLE_PATHS"
        return
    fi
    if [[ "$day" =~ ^[0-9]{1}$ ]]; then
        msg "$f: ${YELLOW}Renaming file:${NOFORMAT} ${day} -> 0${day}"
        mv -f "$ROOT_DIR/$year/$day" "$ROOT_DIR/$year/0$day"
        day="0$day"
    fi

    createSourceUnlessExists "$year" "$day"
}

createSourceUnlessExists() {
    local year="$1"
    local day="$2"
    local src="$SRC_DIR/Y$year/Day$day.hs"

    [ -e "$src" ] && return

    [ -e "$(dirname "$src")" ] || mkdir -p "$(dirname "$src")"
    if [ ! -e "$src" ]; then
        msg "$ROOT_DIR/$year/$day: ${GREEN}Creating template:${NOFORMAT} ${src}"
        sourceTemplate "$year" "$day" > "$src"
    fi
}

sourceTemplate() {
    local year="$1"
    local day="$2"
    IFS='' read -d '' -r tmpl <<'HEREDOC'
module Y%s.Day%s (parts) where

parts = ( (part1, Nothing)
        , (part2, Nothing)
        , id
        )

part1 :: a -> String
part1 input = ""

part2 :: a -> String
part2 input = ""
HEREDOC
    printf -- "$tmpl" "$year" "$day"
}

generatedSolutionsTemplate() {
    IFS='' read -d '' -r tmpl <<'HEREDOC'
-- This File is generated by scripts/generate-sources.sh.
{-# LANGUAGE ImportQualifiedPost, TemplateHaskell #-}
module GeneratedSolutions (inputsDir, lookupInput, solutions, Year, Day) where

import Data.ByteString qualified as BS
import Data.ByteString.UTF8 (toString)
import Data.FileEmbed (embedFile, makeRelativeToProject)
import Solution
%s

type Year = String
type Day  = String

solutions :: [((Year, Day), Solveable DaySolution)]
solutions = concat
    [ %s
    ]
  where
%s

daysFor :: Year
        -> [Solveable DaySolution]
        -> [((Year, Day), Solveable DaySolution)]
daysFor y ps = [ ((y, fmt d), p) | (d, p) <- zip [1..] ps]
  where
    fmt d | d < 10    = '0':show d
          | otherwise = show d

lookupInput :: FilePath -> Maybe String
lookupInput fp = toString <$> lookup fp inputsDir

inputsDir :: [(FilePath, BS.ByteString)]
inputsDir =
    [ %s
    ]
HEREDOC

    local modules="$(generatedSolutionsModules)"
    local years="$(generatedSolutionsYears "$modules")"
    printf -- "$tmpl" \
           "$(generatedSolutionsImports "$modules")" \
           "$(generatedSolutionsSolutions "$years")" \
           "$(generatedSolutionsFunctions "$years" "$modules")" \
           "$(generatedSolutionsInputs)"
}

generatedSolutionsModules() {
    for f in "$SRC_DIR"/Y*/Day*.hs; do
        local day="$(basename "$f" ".hs")"
        local year="$(basename "$(dirname "$f")")"
        echo "$year.$day"
    done
}

generatedSolutionsImports() {
    while IFS= read -r module; do
        echo "import $module qualified"
    done <<< "$1"
}

generatedSolutionsYears() {
    local modules="$1"
    while IFS= read -r module; do
        cut -b2-5 <<< "$module"
    done <<< "$modules" | uniq
}

generatedSolutionsSolutions() {
    local first=1
    while IFS= read -r year; do
        if [ -n "$first" ]; then first=; else printf "    , "; fi
        echo "daysFor \"$year\" days$year"
    done <<< "$1" | uniq
}

generatedSolutionsFunctions() {
    local years="$1"
    local modules="$2"
    while IFS= read -r year; do
        local first=1
        printf "    days$year =\n      [ "

        while IFS= read -r module; do
            if [[ "$module" =~ ^Y${year} ]]; then
                if [ -n "$first" ]; then first=; else printf "      , "; fi
                echo "solve $module.parts"
            fi
        done <<< "$modules"

        printf "      ]\n"
    done <<< "$years"
}

generatedSolutionsInputs() {
    local first=1
    for f in "$ROOT_DIR"/*/*; do
        if [ -n "$first" ]; then first=; else printf "    , "; fi
        local key="$(cut -d/ -f 2- <<< "$f")"
        echo "(\"$key\", \$(makeRelativeToProject \"$f\" >>= embedFile))"
    done
}

setup_colors() {
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
      NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m'
      ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m'
      CYAN='\033[0;36m' YELLOW='\033[1;33m'
  else
      NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
  fi
}

msg() {
  echo >&2 -e "${1-}"
}

die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}

setup_colors

for f in "$ROOT_DIR"/*/*; do
    createSourceFromInputFile "$f"
done

generatedSolutionsTemplate > "$GENERATED_FILE"
